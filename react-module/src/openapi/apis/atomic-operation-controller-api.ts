/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { AddNewInputProductRequest } from '../models';
import { AtomicOperationBasicDto } from '../models';
import { AtomicOperationExtendedDto } from '../models';
import { FailableResourceAtomicOperationExtendedDto } from '../models';
import { FailableResourceAtomicProductExtendedDto } from '../models';
import { FailableResourceDefaultInputProductData } from '../models';
import { FailableResourceString } from '../models';
import { FailableResourceVoid } from '../models';
import { ModifyInputProductRequest } from '../models';
import { OperationDiagramData } from '../models';
import { PageAtomicOperationBasicDto } from '../models';
import { PossibleOperationPathToCopyFrom } from '../models';
import { TreeNodeAtomicOperationExtendedDto } from '../models';
/**
 * AtomicOperationControllerApi - axios parameter creator
 * @export
 */
export const AtomicOperationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddNewInputProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewInputProduct: async (body: AddNewInputProductRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addNewInputProduct.');
            }
            const localVarPath = `/api/atomic-operation/add-new-input-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} operationType 
         * @param {number} endProductId 
         * @param {number} productionOrderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOperationWithEndProduct: async (operationType: number, endProductId: number, productionOrderId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationType' is not null or undefined
            if (operationType === null || operationType === undefined) {
                throw new RequiredError('operationType','Required parameter operationType was null or undefined when calling addOperationWithEndProduct.');
            }
            // verify required parameter 'endProductId' is not null or undefined
            if (endProductId === null || endProductId === undefined) {
                throw new RequiredError('endProductId','Required parameter endProductId was null or undefined when calling addOperationWithEndProduct.');
            }
            // verify required parameter 'productionOrderId' is not null or undefined
            if (productionOrderId === null || productionOrderId === undefined) {
                throw new RequiredError('productionOrderId','Required parameter productionOrderId was null or undefined when calling addOperationWithEndProduct.');
            }
            const localVarPath = `/api/atomic-operation/add-operation-with-end-product/{operationType}/{endProductId}/{productionOrderId}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (operationType !== undefined) {
                localVarQueryParameter['operationType'] = operationType;
            }

            if (endProductId !== undefined) {
                localVarQueryParameter['endProductId'] = endProductId;
            }

            if (productionOrderId !== undefined) {
                localVarQueryParameter['productionOrderId'] = productionOrderId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atOpDeleteObject: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atOpDeleteObject.');
            }
            const localVarPath = `/api/atomic-operation/delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atOpGetObject: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling atOpGetObject.');
            }
            const localVarPath = `/api/atomic-operation/get/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atOpGetObjectList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/atomic-operation/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AtomicOperationExtendedDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atOpSaveObject: async (body: AtomicOperationExtendedDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling atOpSaveObject.');
            }
            const localVarPath = `/api/atomic-operation/save`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} operationId 
         * @param {number} operationTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOperationType: async (operationId: number, operationTypeId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            if (operationId === null || operationId === undefined) {
                throw new RequiredError('operationId','Required parameter operationId was null or undefined when calling changeOperationType.');
            }
            // verify required parameter 'operationTypeId' is not null or undefined
            if (operationTypeId === null || operationTypeId === undefined) {
                throw new RequiredError('operationTypeId','Required parameter operationTypeId was null or undefined when calling changeOperationType.');
            }
            const localVarPath = `/api/atomic-operation/change-operation-type/{operationId}/{operationTypeId}`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)))
                .replace(`{${"operationTypeId"}}`, encodeURIComponent(String(operationTypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} srcProductId 
         * @param {number} dstProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyOperationProcedure: async (srcProductId: number, dstProductId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'srcProductId' is not null or undefined
            if (srcProductId === null || srcProductId === undefined) {
                throw new RequiredError('srcProductId','Required parameter srcProductId was null or undefined when calling copyOperationProcedure.');
            }
            // verify required parameter 'dstProductId' is not null or undefined
            if (dstProductId === null || dstProductId === undefined) {
                throw new RequiredError('dstProductId','Required parameter dstProductId was null or undefined when calling copyOperationProcedure.');
            }
            const localVarPath = `/api/atomic-operation/copy-operation-procedure/{srcProductId}/{dstProductId}`
                .replace(`{${"srcProductId"}}`, encodeURIComponent(String(srcProductId)))
                .replace(`{${"dstProductId"}}`, encodeURIComponent(String(dstProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperationsWithSubEntities: async (operationId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            if (operationId === null || operationId === undefined) {
                throw new RequiredError('operationId','Required parameter operationId was null or undefined when calling deleteOperationsWithSubEntities.');
            }
            const localVarPath = `/api/atomic-operation/delete-operation-with-sub-entities/{operationId}`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAtomicOperationsByIds: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAtomicOperationsByIds.');
            }
            const localVarPath = `/api/atomic-operation/list-atomic-operations-by-type-id`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAtomicOperationsWithNotStartedResult: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/atomic-operation/list-not-started-result`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultInputProductDataForOperation: async (operationId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            if (operationId === null || operationId === undefined) {
                throw new RequiredError('operationId','Required parameter operationId was null or undefined when calling getDefaultInputProductDataForOperation.');
            }
            const localVarPath = `/api/atomic-operation/default-input-product-data-for-operation/{operationId}`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultInputProductNameForOperation: async (operationId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            if (operationId === null || operationId === undefined) {
                throw new RequiredError('operationId','Required parameter operationId was null or undefined when calling getDefaultInputProductNameForOperation.');
            }
            const localVarPath = `/api/atomic-operation/default-input-product-name-for-operation/{operationId}`
                .replace(`{${"operationId"}}`, encodeURIComponent(String(operationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} atomicProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpSetForProduct: async (atomicProductId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'atomicProductId' is not null or undefined
            if (atomicProductId === null || atomicProductId === undefined) {
                throw new RequiredError('atomicProductId','Required parameter atomicProductId was null or undefined when calling getOpSetForProduct.');
            }
            const localVarPath = `/api/atomic-operation/get-op-set-for-product/{atomicProductId}`
                .replace(`{${"atomicProductId"}}`, encodeURIComponent(String(atomicProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pageNumber 
         * @param {number} pageSize 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationsQualifiedForCutting: async (pageNumber: number, pageSize: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageNumber' is not null or undefined
            if (pageNumber === null || pageNumber === undefined) {
                throw new RequiredError('pageNumber','Required parameter pageNumber was null or undefined when calling getOperationsQualifiedForCutting.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getOperationsQualifiedForCutting.');
            }
            const localVarPath = `/api/atomic-operation/qualified-for-cutting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pageNumber 
         * @param {number} pageSize 
         * @param {string} searchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationsQualifiedForCuttingWithSearch: async (pageNumber: number, pageSize: number, searchQuery: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageNumber' is not null or undefined
            if (pageNumber === null || pageNumber === undefined) {
                throw new RequiredError('pageNumber','Required parameter pageNumber was null or undefined when calling getOperationsQualifiedForCuttingWithSearch.');
            }
            // verify required parameter 'pageSize' is not null or undefined
            if (pageSize === null || pageSize === undefined) {
                throw new RequiredError('pageSize','Required parameter pageSize was null or undefined when calling getOperationsQualifiedForCuttingWithSearch.');
            }
            // verify required parameter 'searchQuery' is not null or undefined
            if (searchQuery === null || searchQuery === undefined) {
                throw new RequiredError('searchQuery','Required parameter searchQuery was null or undefined when calling getOperationsQualifiedForCuttingWithSearch.');
            }
            const localVarPath = `/api/atomic-operation/qualified-for-cutting-with-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (searchQuery !== undefined) {
                localVarQueryParameter['searchQuery'] = searchQuery;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} completedProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPossibleOperationPathsToCopyFrom: async (completedProductId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'completedProductId' is not null or undefined
            if (completedProductId === null || completedProductId === undefined) {
                throw new RequiredError('completedProductId','Required parameter completedProductId was null or undefined when calling getPossibleOperationPathsToCopyFrom.');
            }
            const localVarPath = `/api/atomic-operation/get-possible-operation-paths-to-copy-from/{completedProductId}`
                .replace(`{${"completedProductId"}}`, encodeURIComponent(String(completedProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ModifyInputProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInputProduct: async (body: ModifyInputProductRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modifyInputProduct.');
            }
            const localVarPath = `/api/atomic-operation/modify-input-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OperationDiagramData} body 
         * @param {number} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOperationDiagramData: async (body: OperationDiagramData, productId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setOperationDiagramData.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling setOperationDiagramData.');
            }
            const localVarPath = `/api/atomic-operation/operation-diagram-data/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AtomicOperationBasicDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBasicData: async (body: AtomicOperationBasicDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateBasicData.');
            }
            const localVarPath = `/api/atomic-operation/update-basic-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AtomicOperationExtendedDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExtendedData: async (body: AtomicOperationExtendedDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateExtendedData.');
            }
            const localVarPath = `/api/atomic-operation/update-extended-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AtomicOperationControllerApi - functional programming interface
 * @export
 */
export const AtomicOperationControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddNewInputProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNewInputProduct(body: AddNewInputProductRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FailableResourceAtomicProductExtendedDto>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).addNewInputProduct(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} operationType 
         * @param {number} endProductId 
         * @param {number} productionOrderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOperationWithEndProduct(operationType: number, endProductId: number, productionOrderId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FailableResourceAtomicOperationExtendedDto>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).addOperationWithEndProduct(operationType, endProductId, productionOrderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async atOpDeleteObject(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).atOpDeleteObject(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async atOpGetObject(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AtomicOperationExtendedDto>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).atOpGetObject(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async atOpGetObjectList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AtomicOperationBasicDto>>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).atOpGetObjectList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {AtomicOperationExtendedDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async atOpSaveObject(body: AtomicOperationExtendedDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FailableResourceAtomicOperationExtendedDto>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).atOpSaveObject(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} operationId 
         * @param {number} operationTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeOperationType(operationId: number, operationTypeId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FailableResourceVoid>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).changeOperationType(operationId, operationTypeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} srcProductId 
         * @param {number} dstProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyOperationProcedure(srcProductId: number, dstProductId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FailableResourceVoid>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).copyOperationProcedure(srcProductId, dstProductId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOperationsWithSubEntities(operationId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FailableResourceVoid>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).deleteOperationsWithSubEntities(operationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAtomicOperationsByIds(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AtomicOperationBasicDto>>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).getAtomicOperationsByIds(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAtomicOperationsWithNotStartedResult(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AtomicOperationBasicDto>>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).getAtomicOperationsWithNotStartedResult(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultInputProductDataForOperation(operationId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FailableResourceDefaultInputProductData>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).getDefaultInputProductDataForOperation(operationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultInputProductNameForOperation(operationId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FailableResourceString>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).getDefaultInputProductNameForOperation(operationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} atomicProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpSetForProduct(atomicProductId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreeNodeAtomicOperationExtendedDto>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).getOpSetForProduct(atomicProductId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} pageNumber 
         * @param {number} pageSize 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOperationsQualifiedForCutting(pageNumber: number, pageSize: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageAtomicOperationBasicDto>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).getOperationsQualifiedForCutting(pageNumber, pageSize, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} pageNumber 
         * @param {number} pageSize 
         * @param {string} searchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOperationsQualifiedForCuttingWithSearch(pageNumber: number, pageSize: number, searchQuery: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageAtomicOperationBasicDto>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).getOperationsQualifiedForCuttingWithSearch(pageNumber, pageSize, searchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} completedProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPossibleOperationPathsToCopyFrom(completedProductId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PossibleOperationPathToCopyFrom>>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).getPossibleOperationPathsToCopyFrom(completedProductId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ModifyInputProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyInputProduct(body: ModifyInputProductRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FailableResourceAtomicProductExtendedDto>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).modifyInputProduct(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {OperationDiagramData} body 
         * @param {number} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOperationDiagramData(body: OperationDiagramData, productId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FailableResourceVoid>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).setOperationDiagramData(body, productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {AtomicOperationBasicDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBasicData(body: AtomicOperationBasicDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).updateBasicData(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {AtomicOperationExtendedDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExtendedData(body: AtomicOperationExtendedDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AtomicOperationControllerApiAxiosParamCreator(configuration).updateExtendedData(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AtomicOperationControllerApi - factory interface
 * @export
 */
export const AtomicOperationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {AddNewInputProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewInputProduct(body: AddNewInputProductRequest, options?: any): AxiosPromise<FailableResourceAtomicProductExtendedDto> {
            return AtomicOperationControllerApiFp(configuration).addNewInputProduct(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} operationType 
         * @param {number} endProductId 
         * @param {number} productionOrderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOperationWithEndProduct(operationType: number, endProductId: number, productionOrderId: number, options?: any): AxiosPromise<FailableResourceAtomicOperationExtendedDto> {
            return AtomicOperationControllerApiFp(configuration).addOperationWithEndProduct(operationType, endProductId, productionOrderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atOpDeleteObject(id: number, options?: any): AxiosPromise<string> {
            return AtomicOperationControllerApiFp(configuration).atOpDeleteObject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atOpGetObject(id: number, options?: any): AxiosPromise<AtomicOperationExtendedDto> {
            return AtomicOperationControllerApiFp(configuration).atOpGetObject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atOpGetObjectList(options?: any): AxiosPromise<Array<AtomicOperationBasicDto>> {
            return AtomicOperationControllerApiFp(configuration).atOpGetObjectList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AtomicOperationExtendedDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        atOpSaveObject(body: AtomicOperationExtendedDto, options?: any): AxiosPromise<FailableResourceAtomicOperationExtendedDto> {
            return AtomicOperationControllerApiFp(configuration).atOpSaveObject(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} operationId 
         * @param {number} operationTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOperationType(operationId: number, operationTypeId: number, options?: any): AxiosPromise<FailableResourceVoid> {
            return AtomicOperationControllerApiFp(configuration).changeOperationType(operationId, operationTypeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} srcProductId 
         * @param {number} dstProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyOperationProcedure(srcProductId: number, dstProductId: number, options?: any): AxiosPromise<FailableResourceVoid> {
            return AtomicOperationControllerApiFp(configuration).copyOperationProcedure(srcProductId, dstProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOperationsWithSubEntities(operationId: number, options?: any): AxiosPromise<FailableResourceVoid> {
            return AtomicOperationControllerApiFp(configuration).deleteOperationsWithSubEntities(operationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAtomicOperationsByIds(id: number, options?: any): AxiosPromise<Array<AtomicOperationBasicDto>> {
            return AtomicOperationControllerApiFp(configuration).getAtomicOperationsByIds(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAtomicOperationsWithNotStartedResult(options?: any): AxiosPromise<Array<AtomicOperationBasicDto>> {
            return AtomicOperationControllerApiFp(configuration).getAtomicOperationsWithNotStartedResult(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultInputProductDataForOperation(operationId: number, options?: any): AxiosPromise<FailableResourceDefaultInputProductData> {
            return AtomicOperationControllerApiFp(configuration).getDefaultInputProductDataForOperation(operationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} operationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultInputProductNameForOperation(operationId: number, options?: any): AxiosPromise<FailableResourceString> {
            return AtomicOperationControllerApiFp(configuration).getDefaultInputProductNameForOperation(operationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} atomicProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpSetForProduct(atomicProductId: number, options?: any): AxiosPromise<TreeNodeAtomicOperationExtendedDto> {
            return AtomicOperationControllerApiFp(configuration).getOpSetForProduct(atomicProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} pageNumber 
         * @param {number} pageSize 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationsQualifiedForCutting(pageNumber: number, pageSize: number, options?: any): AxiosPromise<PageAtomicOperationBasicDto> {
            return AtomicOperationControllerApiFp(configuration).getOperationsQualifiedForCutting(pageNumber, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} pageNumber 
         * @param {number} pageSize 
         * @param {string} searchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationsQualifiedForCuttingWithSearch(pageNumber: number, pageSize: number, searchQuery: string, options?: any): AxiosPromise<PageAtomicOperationBasicDto> {
            return AtomicOperationControllerApiFp(configuration).getOperationsQualifiedForCuttingWithSearch(pageNumber, pageSize, searchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} completedProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPossibleOperationPathsToCopyFrom(completedProductId: number, options?: any): AxiosPromise<Array<PossibleOperationPathToCopyFrom>> {
            return AtomicOperationControllerApiFp(configuration).getPossibleOperationPathsToCopyFrom(completedProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ModifyInputProductRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInputProduct(body: ModifyInputProductRequest, options?: any): AxiosPromise<FailableResourceAtomicProductExtendedDto> {
            return AtomicOperationControllerApiFp(configuration).modifyInputProduct(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OperationDiagramData} body 
         * @param {number} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOperationDiagramData(body: OperationDiagramData, productId: number, options?: any): AxiosPromise<FailableResourceVoid> {
            return AtomicOperationControllerApiFp(configuration).setOperationDiagramData(body, productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AtomicOperationBasicDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBasicData(body: AtomicOperationBasicDto, options?: any): AxiosPromise<string> {
            return AtomicOperationControllerApiFp(configuration).updateBasicData(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AtomicOperationExtendedDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExtendedData(body: AtomicOperationExtendedDto, options?: any): AxiosPromise<string> {
            return AtomicOperationControllerApiFp(configuration).updateExtendedData(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AtomicOperationControllerApi - object-oriented interface
 * @export
 * @class AtomicOperationControllerApi
 * @extends {BaseAPI}
 */
export class AtomicOperationControllerApi extends BaseAPI {
    /**
     * 
     * @param {AddNewInputProductRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public addNewInputProduct(body: AddNewInputProductRequest, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).addNewInputProduct(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {number} operationType 
     * @param {number} endProductId 
     * @param {number} productionOrderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public addOperationWithEndProduct(operationType: number, endProductId: number, productionOrderId: number, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).addOperationWithEndProduct(operationType, endProductId, productionOrderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public atOpDeleteObject(id: number, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).atOpDeleteObject(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public atOpGetObject(id: number, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).atOpGetObject(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public atOpGetObjectList(options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).atOpGetObjectList(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {AtomicOperationExtendedDto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public atOpSaveObject(body: AtomicOperationExtendedDto, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).atOpSaveObject(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {number} operationId 
     * @param {number} operationTypeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public changeOperationType(operationId: number, operationTypeId: number, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).changeOperationType(operationId, operationTypeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {number} srcProductId 
     * @param {number} dstProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public copyOperationProcedure(srcProductId: number, dstProductId: number, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).copyOperationProcedure(srcProductId, dstProductId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {number} operationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public deleteOperationsWithSubEntities(operationId: number, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).deleteOperationsWithSubEntities(operationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public getAtomicOperationsByIds(id: number, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).getAtomicOperationsByIds(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public getAtomicOperationsWithNotStartedResult(options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).getAtomicOperationsWithNotStartedResult(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {number} operationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public getDefaultInputProductDataForOperation(operationId: number, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).getDefaultInputProductDataForOperation(operationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {number} operationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public getDefaultInputProductNameForOperation(operationId: number, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).getDefaultInputProductNameForOperation(operationId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {number} atomicProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public getOpSetForProduct(atomicProductId: number, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).getOpSetForProduct(atomicProductId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {number} pageNumber 
     * @param {number} pageSize 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public getOperationsQualifiedForCutting(pageNumber: number, pageSize: number, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).getOperationsQualifiedForCutting(pageNumber, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {number} pageNumber 
     * @param {number} pageSize 
     * @param {string} searchQuery 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public getOperationsQualifiedForCuttingWithSearch(pageNumber: number, pageSize: number, searchQuery: string, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).getOperationsQualifiedForCuttingWithSearch(pageNumber, pageSize, searchQuery, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {number} completedProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public getPossibleOperationPathsToCopyFrom(completedProductId: number, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).getPossibleOperationPathsToCopyFrom(completedProductId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {ModifyInputProductRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public modifyInputProduct(body: ModifyInputProductRequest, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).modifyInputProduct(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {OperationDiagramData} body 
     * @param {number} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public setOperationDiagramData(body: OperationDiagramData, productId: number, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).setOperationDiagramData(body, productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {AtomicOperationBasicDto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public updateBasicData(body: AtomicOperationBasicDto, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).updateBasicData(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {AtomicOperationExtendedDto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AtomicOperationControllerApi
     */
    public updateExtendedData(body: AtomicOperationExtendedDto, options?: any) {
        return AtomicOperationControllerApiFp(this.configuration).updateExtendedData(body, options).then((request) => request(this.axios, this.basePath));
    }
}
